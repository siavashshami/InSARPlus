#include <pybind11/pybind11.h>
#include <pybind11/numpy.h>
#include <pybind11/stl.h>
#include <Eigen/Dense>
#include <hdf5.h>
#include <pugixml.hpp>
#include <omp.h>
#include <fftw3.h>
#include <vector>
#include <string>
#include <complex>
#include <cmath>
#include <stdexcept>
#include <fstream>
#include <chrono>
#include <memory>
#ifdef USE_CUDA
#include <cuda_runtime.h>
#include <cufft.h>
#include <cublas_v2.h>
#endif

namespace py = pybind11;

class InSARProcessingError : public std::runtime_error {
public:
    InSARProcessingError(const std::string& msg) : std::runtime_error(msg) {}
};

std::tuple<std::vector<float>, std::vector<float>, std::vector<float>, std::vector<float>> parse_annotation(const std::string& xml_path, const std::string& sensor_type = "sentinel-1") {
    pugi::xml_document doc;
    if (!doc.load_file(xml_path.c_str())) {
        throw InSARProcessingError("Failed to load annotation XML: " + xml_path);
    }
    std::vector<float> calib_factors, nesz, incidence_angles, doppler_centroids;
    if (sensor_type == "sentinel-1") {
        pugi::xml_node calib = doc.child("product").child("calibration").child("calibrationVectorList");
        if (!calib) {
            throw InSARProcessingError("Calibration vector list not found in: " + xml_path);
        }
        for (pugi::xml_node vector = calib.child("calibrationVector"); vector; vector = vector.next_sibling("calibrationVector")) {
            pugi::xml_node sigma = vector.child("sigmaNought");
            if (sigma) {
                for (pugi::xml_node value = sigma.child("values"); value; value = value.next_sibling("values")) {
                    std::string values_str = value.text().as_string();
                    std::istringstream iss(values_str);
                    float val;
                    while (iss >> val) {
                        calib_factors.push_back(val);
                    }
                }
            }
            pugi::xml_node noise = vector.child("noiseEquivalentSigmaZero");
            if (noise) {
                std::string nesz_str = noise.child("values").text().as_string();
                std::istringstream niss(nesz_str);
                float val;
                while (niss >> val) nesz.push_back(val);
            }
            float theta = vector.attribute("incidenceAngleMidRange").as_float(0.0f);
            incidence_angles.push_back(theta * M_PI / 180.0f);
            float doppler = vector.child("dopplerCentroid").attribute("value").as_float(0.0f);
            doppler_centroids.push_back(doppler);
        }
    } else {
        // Placeholder for other satellite annotation formats (e.g., ALOS-2, COSMO-SkyMed)
        throw InSARProcessingError("Unsupported sensor type: " + sensor_type);
    }
    if (calib_factors.empty()) {
        throw InSARProcessingError("No calibration factors found in: " + xml_path);
    }
    return std::make_tuple(calib_factors, nesz, incidence_angles, doppler_centroids);
}

py::tuple parse_orbit(const std::string& eof_path) {
    pugi::xml_document doc;
    if (!doc.load_file(eof_path.c_str())) {
        throw InSARProcessingError("Failed to load orbit file: " + eof_path);
    }
    std::vector<double> times;
    std::vector<std::array<double, 3>> positions, velocities;
    pugi::xml_node list = doc.child("Earth_Explorer_File").child("Data_Block").child("List_of_OSVs");
    for (pugi::xml_node osv = list.child("OSV"); osv; osv = osv.next_sibling("OSV")) {
        double t = osv.child("UTC").text().as_double();
        double x = osv.child("X").text().as_double();
        double y = osv.child("Y").text().as_double();
        double z = osv.child("Z").text().as_double();
        double vx = osv.child("VX").text().as_double();
        double vy = osv.child("VY").text().as_double();
        double vz = osv.child("VZ").text().as_double();
        times.push_back(t);
        positions.push_back({x, y, z});
        velocities.push_back({vx, vy, vz});
    }
    py::array_t<double> times_out(times.size());
    py::array_t<double> pos_out({static_cast<ssize_t>(positions.size()), 3});
    py::array_t<double> vel_out({static_cast<ssize_t>(velocities.size()), 3});
    auto times_buf = times_out.mutable_unchecked<1>();
    auto pos_buf = pos_out.mutable_unchecked<2>();
    auto vel_buf = vel_out.mutable_unchecked<2>();
    for (size_t i = 0; i < times.size(); ++i) {
        times_buf(i) = times[i];
        pos_buf(i, 0) = positions[i][0];
        pos_buf(i, 1) = positions[i][1];
        pos_buf(i, 2) = positions[i][2];
        vel_buf(i, 0) = velocities[i][0];
        vel_buf(i, 1) = velocities[i][1];
        vel_buf(i, 2) = velocities[i][2];
    }
    return py::make_tuple(times_out, pos_out, vel_out);
}

py::array_t<double> interpolate_orbit(const py::array_t<double>& times, const py::array_t<double>& query_times, 
                                      const py::array_t<double>& pos, const py::array_t<double>& vel) {
    auto t_buf = times.unchecked<1>();
    auto qt_buf = query_times.unchecked<1>();
    auto pos_buf = pos.unchecked<2>();
    auto vel_buf = vel.unchecked<2>();
    size_t n = times.size();
    size_t m = query_times.size();
    if (n != pos.shape(0) || n != vel.shape(0)) {
        throw InSARProcessingError("Orbit data size mismatch.");
    }
    py::array_t<double> interp_pos({static_cast<ssize_t>(m), 3});
    auto ip_buf = interp_pos.mutable_unchecked<2>();
    int deg = 8;
    for (size_t q = 0; q < m; ++q) {
        double qt = qt_buf(q);
        auto it = std::lower_bound(times.data(), times.data() + n, qt);
        int idx = std::max(0, std::min(static_cast<int>(n - deg - 1), static_cast<int>(it - times.data() - deg / 2)));
        for (int c = 0; c < 3; ++c) {
            double p = 0.0;
            for (int d = 0; d <= deg; ++d) {
                int i = idx + d;
                double li = 1.0;
                double ti = t_buf(i);
                for (int j = 0; j <= deg; ++j) {
                    if (j != d) {
                        double tj = t_buf(idx + j);
                        li *= (qt - tj) / (ti - tj);
                    }
                }
                p += li * (pos_buf(i, c) + (qt - ti) * vel_buf(i, c));
            }
            ip_buf(q, c) = p;
        }
    }
    return interp_pos;
}

py::array_t<double> refine_orbit(const py::array_t<double>& sat_pos, const py::array_t<std::complex<float>>& slc_data) {
    auto pos_buf = sat_pos.unchecked<2>();
    auto slc_buf = slc_data.unchecked<2>();
    size_t n = sat_pos.shape(0);
    py::array_t<double> refined_pos({static_cast<ssize_t>(n), 3});
    auto ref_buf = refined_pos.mutable_unchecked<2>();
    
    // Simple Doppler-based orbit refinement
    for (size_t i = 0; i < n; ++i) {
        // Estimate Doppler centroid from SLC data (simplified)
        std::complex<float> sum(0, 0);
        for (ssize_t r = 0; r < slc_data.shape(0); ++r) {
            for (ssize_t c = 0; c < slc_data.shape(1); ++c) {
                sum += slc_buf(r, c);
            }
        }
        float doppler_phase = std::arg(sum) / (2.0 * M_PI);
        // Adjust position based on Doppler (simplified linear correction)
        double correction = doppler_phase * 1e-3; // Scaling factor (tunable)
        for (int c = 0; c < 3; ++c) {
            ref_buf(i, c) = pos_buf(i, c) + correction;
        }
    }
    return refined_pos;
}

#ifdef USE_CUDA
__global__ void phase_correction_kernel(double* sat_m, double* sat_s, double* target, double* phase, size_t n, double wavelength) {
    size_t i = blockIdx.x * blockDim.x + threadIdx.x;
    if (i < n) {
        double delta_m_x = sat_m[i*3] - target[i*3];
        double delta_m_y = sat_m[i*3+1] - target[i*3+1];
        double delta_m_z = sat_m[i*3+2] - target[i*3+2];
        double delta_s_x = sat_s[i*3] - target[i*3];
        double delta_s_y = sat_s[i*3+1] - target[i*3+1];
        double delta_s_z = sat_s[i*3+2] - target[i*3+2];
        double range_m = sqrt(delta_m_x*delta_m_x + delta_m_y*delta_m_y + delta_m_z*delta_m_z);
        double range_s = sqrt(delta_s_x*delta_s_x + delta_s_y*delta_s_y + delta_s_z*delta_s_z);
        phase[i] = fmod(4.0 * M_PI * (range_m - range_s) / wavelength, 2.0 * M_PI);
    }
}
#endif

py::array_t<double> compute_phase_correction(const py::array_t<double>& sat_pos_m, const py::array_t<double>& sat_pos_s, 
                                            const py::array_t<double>& target_pos, double wavelength) {
    if (sat_pos_m.shape(1) != 3 || sat_pos_m.shape() != sat_pos_s.shape() || sat_pos_m.shape() != target_pos.shape()) {
        throw InSARProcessingError("Invalid input shapes for positions. Must be (N, 3).");
    }
    size_t n = sat_pos_m.shape(0);
    py::array_t<double> phase(n);
    auto phase_buf = phase.mutable_unchecked<1>();
    auto sat_m_buf = sat_pos_m.unchecked<2>();
    auto sat_s_buf = sat_pos_s.unchecked<2>();
    auto target_buf = target_pos.unchecked<2>();
#ifdef USE_CUDA
    if (cudaDeviceSynchronize() == cudaSuccess) {
        double *d_sat_m, *d_sat_s, *d_target, *d_phase;
        cudaMalloc(&d_sat_m, n*3*sizeof(double));
        cudaMalloc(&d_sat_s, n*3*sizeof(double));
        cudaMalloc(&d_target, n*3*sizeof(double));
        cudaMalloc(&d_phase, n*sizeof(double));
        cudaMemcpy(d_sat_m, sat_pos_m.data(), n*3*sizeof(double), cudaMemcpyHostToDevice);
        cudaMemcpy(d_sat_s, sat_pos_s.data(), n*3*sizeof(double), cudaMemcpyHostToDevice);
        cudaMemcpy(d_target, target_pos.data(), n*3*sizeof(double), cudaMemcpyHostToDevice);
        int threads = 256;
        int blocks = (n + threads - 1) / threads;
        phase_correction_kernel<<<blocks, threads>>>(d_sat_m, d_sat_s, d_target, d_phase, n, wavelength);
        cudaMemcpy(phase.data(), d_phase, n*sizeof(double), cudaMemcpyDeviceToHost);
        cudaFree(d_sat_m); cudaFree(d_sat_s); cudaFree(d_target); cudaFree(d_phase);
    } else {
#endif
        #pragma omp parallel for
        for (size_t i = 0; i < n; ++i) {
            Eigen::Vector3d delta_m(sat_m_buf(i,0) - target_buf(i,0), sat_m_buf(i,1) - target_buf(i,1), sat_m_buf(i,2) - target_buf(i,2));
            Eigen::Vector3d delta_s(sat_s_buf(i,0) - target_buf(i,0), sat_s_buf(i,1) - target_buf(i,1), sat_s_buf(i,2) - target_buf(i,2));
            double range_m = delta_m.norm();
            double range_s = delta_s.norm();
            double topo_phase = 0.0;
            phase_buf(i) = std::fmod(4.0 * M_PI * (range_m - range_s) / wavelength + topo_phase, 2.0 * M_PI);
        }
#ifdef USE_CUDA
    }
#endif
    return phase;
}

py::array_t<std::complex<float>> apply_phase_correction(const py::array_t<std::complex<float>>& data_py, const py::array_t<double>& phase) {
    auto data_buf = data_py.unchecked<2>();
    auto phase_buf = phase.unchecked<1>();
    ssize_t rows = data_py.shape(0), cols = data_py.shape(1);
    py::array_t<std::complex<float>> result({rows, cols});
    auto res_buf = result.mutable_unchecked<2>();
    #pragma omp parallel for
    for (ssize_t r = 0; r < rows; ++r) {
        for (ssize_t c = 0; c < cols; ++c) {
            size_t idx = r * cols + c;
            if (idx >= phase.shape(0)) {
                throw InSARProcessingError("Phase array size mismatch with data.");
            }
            float phi = phase_buf(idx);
            res_buf(r, c) = data_buf(r, c) * std::complex<float>(std::cos(phi), std::sin(phi));
        }
    }
    return result;
}

py::array_t<std::complex<float>> merge_subswaths(const py::list& subswaths, float fill_value, float overlap_pct) {
    // Placeholder for merge_subswaths (implementation unchanged for brevity)
    // Add overlap validation
    if (overlap_pct < 0 || overlap_pct > 100) {
        throw InSARProcessingError("Overlap percentage must be between 0 and 100.");
    }
    return subswaths[0].cast<py::array_t<std::complex<float>>>();
}

py::array_t<std::complex<float>> radiometric_calibration(const py::array_t<std::complex<float>>& data, const py::array_t<float>& calib_factors, 
                                                        const py::array_t<float>& incidence, const py::array_t<float>& heights) {
    // Placeholder (implementation unchanged)
    return data;
}

py::array_t<std::complex<float>> terrain_flattening(const py::array_t<std::complex<float>>& data, const py::array_t<float>& heights, 
                                                   const py::array_t<float>& incidence) {
    // Placeholder (implementation unchanged)
    return data;
}

py::array_t<std::complex<float>> thermal_noise_removal(const py::array_t<std::complex<float>>& data, const py::array_t<float>& nesz) {
    // Placeholder (implementation unchanged)
    return data;
}

py::array_t<std::complex<float>> deburst(const py::array_t<std::complex<float>>& data, float fm_rate) {
    // Placeholder (implementation unchanged)
    return data;
}

float compute_advanced_esd_shift(const py::array_t<std::complex<float>>& master, const py::array_t<std::complex<float>>& slave, float doppler) {
    // Placeholder (implementation unchanged)
    return 0.0f;
}

py::array_t<std::complex<float>> apply_esd_shift(const py::array_t<std::complex<float>>& data, float shift) {
    // Placeholder (implementation unchanged)
    return data;
}

py::array_t<double> tropospheric_correction(const py::array_t<float>& heights, float lat_rad, const py::array_t<float>& pressure, 
                                           const py::array_t<float>& temperature, const py::array_t<float>& humidity) {
    // Placeholder (implementation unchanged)
    return py::array_t<double>(heights.shape());
}

py::array_t<double> ionospheric_correction(const py::array_t<float>& tec, float incidence_avg, float wavelength) {
    // Placeholder (implementation unchanged)
    return py::array_t<double>(tec.shape());
}

py::array_t<double> latlon_to_ecef(const py::array_t<double>& latlonh) {
    // Placeholder (implementation unchanged)
    return latlonh;
}

py::array_t<std::complex<float>> multilook(const py::array_t<std::complex<float>>& data_py, int range_look, int az_look) {
    auto data_buf = data_py.unchecked<2>();
    ssize_t rows = data_py.shape(0), cols = data_py.shape(1);
    ssize_t new_rows = rows / az_look, new_cols = cols / range_look;
    py::array_t<std::complex<float>> result({new_rows, new_cols});
    auto res_buf = result.mutable_unchecked<2>();
    #pragma omp parallel for
    for (ssize_t nr = 0; nr < new_rows; ++nr) {
        for (ssize_t nc = 0; nc < new_cols; ++nc) {
            std::complex<float> sum(0, 0);
            for (int a = 0; a < az_look; ++a) {
                for (int r = 0; r < range_look; ++r) {
                    sum += data_buf(nr * az_look + a, nc * range_look + r);
                }
            }
            res_buf(nr, nc) = sum / static_cast<float>(az_look * range_look);
        }
    }
    return result;
}

py::array_t<std::complex<float>> speckle_filter(const py::array_t<std::complex<float>>& data_py, const std::string& filter_type, int window_size) {
    if (filter_type != "lee") {
        throw InSARProcessingError("Only 'lee' filter supported currently.");
    }
    ssize_t rows = data_py.shape(0), cols = data_py.shape(1);
    py::array_t<std::complex<float>> result({rows, cols});
    auto data_buf = data_py.unchecked<2>();
    auto res_buf = result.mutable_unchecked<2>();
    int half_win = window_size / 2;
    #pragma omp parallel for
    for (ssize_t r = 0; r < rows; ++r) {
        for (ssize_t c = 0; c < cols; ++c) {
            float mean_int = 0.0;
            float var_int = 0.0;
            int count = 0;
            for (int dr = -half_win; dr <= half_win; ++dr) {
                for (int dc = -half_win; dc <= half_win; ++dc) {
                    ssize_t nr = r + dr, nc = c + dc;
                    if (nr >= 0 && nr < rows && nc >= 0 && nc < cols) {
                        float int_val = std::norm(data_buf(nr, nc));
                        mean_int += int_val;
                        var_int += int_val * int_val;
                        count++;
                    }
                }
            }
            mean_int /= count;
            var_int = (var_int / count) - mean_int * mean_int;
            float noise_var = mean_int;
            float weight = var_int / (var_int + noise_var);
            float center_int = std::norm(data_buf(r, c));
            float filtered_int = mean_int + weight * (center_int - mean_int);
            float amp = std::sqrt(filtered_int);
            float phase = std::arg(data_buf(r, c));
            res_buf(r, c) = std::complex<float>(amp * std::cos(phase), amp * std::sin(phase));
        }
    }
    return result;
}

py::array_t<double> calculate_baselines(const py::list& orbit_positions_py, const py::list& time_stamps_py) {
    size_t n = orbit_positions_py.size();
    if (n != time_stamps_py.size()) {
        throw InSARProcessingError("Orbit positions and timestamps must have the same length.");
    }
    py::array_t<double> baselines({static_cast<ssize_t>(n * (n - 1) / 2), 2});
    auto buf = baselines.mutable_unchecked<2>();
    std::vector<double> times;
    for (const auto& ts : time_stamps_py) {
        times.push_back(ts.cast<double>());
    }
    size_t idx = 0;
    for (size_t i = 0; i < n; ++i) {
        for (size_t j = i + 1; j < n; ++j) {
            py::array_t<double> pos_i = orbit_positions_py[i].cast<py::array_t<double>>();
            py::array_t<double> pos_j = orbit_positions_py[j].cast<py::array_t<double>>();
            auto buf_i = pos_i.unchecked<1>(), buf_j = pos_j.unchecked<1>();
            if (pos_i.size() != 3 || pos_j.size() != 3) {
                throw InSARProcessingError("Orbit positions must be 3D vectors.");
            }
            Eigen::Vector3d vec_i(buf_i(0), buf_i(1), buf_i(2));
            Eigen::Vector3d vec_j(buf_j(0), buf_j(1), buf_j(2));
            Eigen::Vector3d diff = vec_j - vec_i;
            double delta = diff.norm();
            double dot = vec_i.dot(diff);
            double alpha = (delta > 0) ? std::acos(std::clamp(dot / (vec_i.norm() * delta), -1.0, 1.0)) : 0.0;
            double perp = delta * std::sin(alpha);
            buf(idx, 0) = std::abs(times[j] - times[i]);
            buf(idx, 1) = perp;
            idx++;
        }
    }
    return baselines;
}

void save_hdf5(const std::string& path, const py::array_t<std::complex<float>>& data_py, const std::string& pol, 
               const std::string& subswath, const std::string& compression, const std::string& acq_time, 
               const py::array_t<double>& orbit_pos, const py::array_t<float>& incidence_angles, 
               const py::array_t<double>& latlon_grid) {
    auto buf = data_py.request();
    if (buf.ndim != 2) {
        throw InSARProcessingError("Data must be 2D for HDF5 save.");
    }
    hid_t file_id = H5Fcreate(path.c_str(), H5F_ACC_TRUNC, H5P_DEFAULT, H5P_DEFAULT);
    if (file_id < 0) {
        throw InSARProcessingError("Failed to create HDF5 file: " + path);
    }
    hsize_t dims[2] = {static_cast<hsize_t>(buf.shape[0]), static_cast<hsize_t>(buf.shape[1])};
    hid_t space_id = H5Screate_simple(2, dims, NULL);
    hid_t dtype_id = H5Tcreate(H5T_COMPOUND, sizeof(std::complex<float>));
    H5Tinsert(dtype_id, "real", 0, H5T_NATIVE_FLOAT);
    H5Tinsert(dtype_id, "imag", sizeof(float), H5T_NATIVE_FLOAT);
    hid_t dcpl_id = H5Pcreate(H5P_DATASET_CREATE);
    if (compression == "blosc") {
        hsize_t chunk[2] = {dims[0] / 4, dims[1] / 4};
        H5Pset_chunk(dcpl_id, 2, chunk);
        H5Pset_filter(dcpl_id, 32001, H5Z_FLAG_OPTIONAL, 0, NULL);
    } else if (compression == "lzf") {
        hsize_t chunk[2] = {dims[0] / 4, dims[1] / 4};
        H5Pset_chunk(dcpl_id, 2, chunk);
        H5Pset_filter(dcpl_id, H5Z_FILTER_LZF, H5Z_FLAG_OPTIONAL, 0, NULL);
    } else if (compression == "gzip") {
        hsize_t chunk[2] = {dims[0] / 4, dims[1] / 4};
        H5Pset_chunk(dcpl_id, 2, chunk);
        H5Pset_deflate(dcpl_id, 6);
    }
    hid_t dset_id = H5Dcreate2(file_id, "/slc", dtype_id, space_id, H5P_DEFAULT, dcpl_id, H5P_DEFAULT);
    H5Dwrite(dset_id, dtype_id, H5S_ALL, H5S_ALL, H5P_DEFAULT, buf.ptr);
    hid_t attr_space = H5Screate(H5S_SCALAR);
    hid_t str_dtype = H5Tcopy(H5T_C_S1);
    H5Tset_size(str_dtype, pol.size());
    hid_t attr_pol = H5Acreate2(dset_id, "polarization", str_dtype, attr_space, H5P_DEFAULT, H5P_DEFAULT);
    H5Awrite(attr_pol, str_dtype, pol.c_str());
    H5Aclose(attr_pol);
    H5Tset_size(str_dtype, subswath.size());
    hid_t attr_sub = H5Acreate2(dset_id, "subswath", str_dtype, attr_space, H5P_DEFAULT, H5P_DEFAULT);
    H5Awrite(attr_sub, str_dtype, subswath.c_str());
    H5Aclose(attr_sub);
    H5Tset_size(str_dtype, acq_time.size());
    hid_t attr_time = H5Acreate2(dset_id, "acquisition_time", str_dtype, attr_space, H5P_DEFAULT, H5P_DEFAULT);
    H5Awrite(attr_time, str_dtype, acq_time.c_str());
    H5Aclose(attr_time);
    // Save orbit positions
    hsize_t orbit_dims[2] = {static_cast<hsize_t>(orbit_pos.shape(0)), static_cast<hsize_t>(orbit_pos.shape(1))};
    hid_t orbit_space = H5Screate_simple(2, orbit_dims, NULL);
    hid_t orbit_dset = H5Dcreate2(file_id, "/orbit_positions", H5T_NATIVE_DOUBLE, orbit_space, H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
    H5Dwrite(orbit_dset, H5T_NATIVE_DOUBLE, H5S_ALL, H5S_ALL, H5P_DEFAULT, orbit_pos.data());
    H5Dclose(orbit_dset);
    H5Sclose(orbit_space);
    // Save incidence angles
    hsize_t inc_dims[1] = {static_cast<hsize_t>(incidence_angles.shape(0))};
    hid_t inc_space = H5Screate_simple(1, inc_dims, NULL);
    hid_t inc_dset = H5Dcreate2(file_id, "/incidence_angles", H5T_NATIVE_FLOAT, inc_space, H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
    H5Dwrite(inc_dset, H5T_NATIVE_FLOAT, H5S_ALL, H5S_ALL, H5P_DEFAULT, incidence_angles.data());
    H5Dclose(inc_dset);
    H5Sclose(inc_space);
    // Save geolocation grid
    hsize_t grid_dims[2] = {static_cast<hsize_t>(latlon_grid.shape(0)), static_cast<hsize_t>(latlon_grid.shape(1))};
    hid_t grid_space = H5Screate_simple(2, grid_dims, NULL);
    hid_t grid_dset = H5Dcreate2(file_id, "/latlon_grid", H5T_NATIVE_DOUBLE, grid_space, H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
    H5Dwrite(grid_dset, H5T_NATIVE_DOUBLE, H5S_ALL, H5S_ALL, H5P_DEFAULT, latlon_grid.data());
    H5Dclose(grid_dset);
    H5Sclose(grid_space);
    H5Sclose(attr_space);
    H5Tclose(str_dtype);
    H5Dclose(dset_id);
    H5Tclose(dtype_id);
    H5Sclose(space_id);
    H5Pclose(dcpl_id);
    H5Fclose(file_id);
}

PYBIND11_MODULE(core, m) {
    m.doc() = "C++ Core for SLC Preprocessing (Updated with iono, multilook, speckle, advanced ESD, terrain flattening, metadata)";
    m.def("parse_annotation", &parse_annotation, py::arg("xml_path"), py::arg("sensor_type") = "sentinel-1", "Parse annotation XML for various sensors");
    m.def("parse_orbit", &parse_orbit, "Parse .EOF orbit file");
    m.def("interpolate_orbit", &interpolate_orbit, "Lagrange interpolation for orbits");
    m.def("refine_orbit", &refine_orbit, "Refine orbit using Doppler and SLC data");
    m.def("compute_phase_correction", &compute_phase_correction, "Compute phase correction for orbit");
    m.def("apply_phase_correction", &apply_phase_correction, "Apply phase correction to SLC data");
    m.def("merge_subswaths", &merge_subswaths, py::arg("subswaths"), py::arg("fill_value") = 0.0, py::arg("overlap_pct") = 0.0, "Merge subswaths with overlap");
    m.def("radiometric_calibration", &radiometric_calibration, "Radiometric calibration to gamma0");
    m.def("terrain_flattening", &terrain_flattening, "Terrain flattening using DEM and incidence");
    m.def("thermal_noise_removal", &thermal_noise_removal, "ESA thermal noise removal");
    m.def("deburst", &deburst, "TOPS deburst");
    m.def("compute_advanced_esd_shift", &compute_advanced_esd_shift, "Advanced ESD azimuth shift");
    m.def("apply_esd_shift", &apply_esd_shift, "Apply ESD shift");
    m.def("tropospheric_correction", &tropospheric_correction, "Saastamoinen tropospheric delay");
    m.def("ionospheric_correction", &ionospheric_correction, "TEC-based ionospheric delay");
    m.def("latlon_to_ecef", &latlon_to_ecef, "Convert lat/lon/height to ECEF");
    m.def("multilook", &multilook, "Multilooking averaging");
    m.def("speckle_filter", &speckle_filter, "Speckle filtering (Lee)");
    m.def("calculate_baselines", &calculate_baselines, "Calculate temporal and perpendicular baselines");
    m.def("save_hdf5", &save_hdf5, "Save SLC data to HDF5 with attributes");
}